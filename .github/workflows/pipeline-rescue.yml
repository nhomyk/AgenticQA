name: ðŸ†˜ Pipeline Rescue System (Phase -1)

# This runs INDEPENDENTLY and FIRST - before any other workflow
# It detects critical pipeline failures and fixes them
# This is the "circuit breaker" that prevents infinite loops

on:
  push:
    branches: [ main ]
  schedule:
    # Run every 5 minutes to catch failures early
    - cron: '*/5 * * * *'
  workflow_dispatch:

permissions:
  contents: write
  actions: write

jobs:
  pipeline-rescue:
    runs-on: ubuntu-latest
    name: ðŸš¨ Pipeline Health Check & Emergency Repair
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      # STEP 1: Check if main workflow is in a broken state
      - name: Check pipeline health
        id: health
        run: |
          echo "Checking pipeline health status..."
          
          # Get the latest workflow run
          LATEST_RUN=$(gh run list --workflow=ci.yml --branch=main --limit=1 --json conclusion,status,databaseId -q '.[0]')
          
          echo "Latest run: $LATEST_RUN"
          
          if echo "$LATEST_RUN" | grep -q '"FAILURE"'; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "Pipeline is currently FAILED"
          elif echo "$LATEST_RUN" | grep -q '"IN_PROGRESS"'; then
            echo "status=running" >> $GITHUB_OUTPUT
            echo "Pipeline is still running"
          else
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "Pipeline appears healthy"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # STEP 2: If failed, run repairs
      - name: Emergency repair mode
        if: steps.health.outputs.status == 'failed'
        run: |
          echo "ðŸš¨ PIPELINE IN FAILURE STATE - ACTIVATING EMERGENCY REPAIR"
          
          # Install YAML validator
          npm install -g js-yaml
          
          # Validate all workflow files
          for file in .github/workflows/*.yml .github/workflows/*.yaml; do
            if [ -f "$file" ]; then
              echo ""
              echo "Validating: $file"
              node -e "const yaml = require('js-yaml'); const fs = require('fs'); try { yaml.load(fs.readFileSync('$file', 'utf8')); console.log('âœ… Valid'); } catch(e) { console.log('âŒ ERROR:', e.message); process.exit(1); }"
            fi
          done
          
          echo ""
          echo "âœ… All workflows validated"

      # STEP 3: Run repair script
      - name: Run critical repair system
        if: steps.health.outputs.status == 'failed'
        run: |
          node repair-workflow.js
        continue-on-error: true

      # STEP 4: If still broken, create emergency issue
      - name: Create emergency issue if unresolved
        if: failure() && steps.health.outputs.status == 'failed'
        run: |
          gh issue create --title "ðŸš¨ CRITICAL: Pipeline Rescue Failed" --body "Pipeline is in a critical failed state. Manual intervention required. See: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" || true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # STEP 5: Report status
      - name: Report repair result
        run: |
          echo "## ðŸ”§ Pipeline Rescue Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status**: ${{ steps.health.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.health.outputs.status }}" = "healthy" ]; then
            echo "âœ… Pipeline is healthy - no repairs needed" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.health.outputs.status }}" = "failed" ]; then
            echo "ðŸš¨ Pipeline was in FAILURE state" >> $GITHUB_STEP_SUMMARY
            echo "âš™ï¸ Automated repairs applied" >> $GITHUB_STEP_SUMMARY
          fi
