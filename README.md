# ğŸ¤– circleQA.ai - Enterprise-Grade Autonomous QA & Compliance Platform

**Built by Architects with 15+ Years in Tech | Advanced AI-Powered QA System with Built-In Compliance & Security**

circleQA.ai is an enterprise-grade Node.js platform that demonstrates what's possible when deep tech architecture expertise meets autonomous AI. We combine multi-agent collaboration, comprehensive testing infrastructure, **production-ready WCAG 2.1 AA compliance**, **automated security vulnerability scanning**, real-time compliance monitoring, and self-healing CI/CD pipelines. This is battle-tested software built by a team that's architected high-tech systems for Fortune 500 companies, multinational enterprises, and fast-scaling startups. It handles everything from code scanning to legal compliance with **zero manual intervention**.

> âœ… **Built by Expert Architects** â€¢ ğŸ” **Enterprise Security** â€¢ â™¿ **Accessibility First** â€¢ ğŸš€ **Self-Healing Pipelines** â€¢ ğŸ“Š **Compliance Certified**

---

## ğŸ‘¥ Who We Are

**Our team brings 15+ years of deep expertise in tech architecture, AI systems, and enterprise software.**

We've spent over 15 years:
- **Building High-Tech Systems** for Fortune 500 companies, consulting groups, and multinational enterprises
- **Leading Multi-National Teams** across EMEA, Asia-Pacific, and North America
- **Scaling from 0-1** in multiple startups, taking products from concept to market leadership
- **Training AI Agents Beyond Public Data** - Our autonomous agents are taught by experienced architects to become true domain experts
- **Solving Complex Compliance & Security** challenges that traditional approaches can't handle

circleQA.ai is an example of the sophisticated, intelligent systems our team builds. It's not just a toolâ€”it's proof of how 15+ years in architecture, combined with AI expertise, creates systems that rival senior engineers in capability.

---

## ğŸŒŸ Why Trust Our Team to Build This?

### Our Expertise Powers Every Agent
- **Compliance Agent** trained on real enterprise compliance frameworks (GDPR, CCPA, WCAG, ADA, OWASP)
- **SRE Agent** with 15+ years of production incident patterns and failure recovery strategies
- **QA Agent** based on testing best practices from enterprise teams
- **Security Agent** with knowledge of thousands of real-world vulnerabilities
- **Fullstack Agent** understanding architectural patterns that work at scale

### From Fortune 500 to Fast-Growth Startups
We've architected systems for:
- **Global Enterprises**: Multi-timezone coordination, regulatory compliance across regions
- **High-Growth Startups**: Scaling from 0-1, building foundations for hypergrowth
- **Consulting Partnerships**: Strategic technology initiatives with top-tier firms
- **Mission-Critical Systems**: 99.9%+ uptime requirements, zero-trust security models

### That Expertise is Now Embedded in circleQA.ai
Every feature, every compliance check, every recovery pattern comes from real-world experience, not generic training data.

---

## ğŸ¯ What We Can Build Together

If circleQA.ai excites you, imagine what we could build for your organization:

- **Custom Autonomous Systems** tailored to your specific challenges
- **Enterprise Architecture** that scales with your growth
- **AI Agents** trained on your domain expertise
- **Multi-National Team Leadership** for distributed organizations
- **From 0-1 Concept to Production** in weeks, not quarters

Our team doesn't just build softwareâ€”we architect strategic technology advantages.

---

## ğŸ¯ Core Features

### 1. **Multi-Agent Autonomous Architecture** 
Five specialized AI agents that collaborate to ensure perfect code quality and compliance:

- **ğŸ›¡ï¸ Compliance Agent** (1,200 lines)
  - 175+ compliance checks across 7 standards (GDPR, CCPA, WCAG 2.1, ADA, OWASP, Licensing, Legal)
  - Automatic policy generation (Privacy Policy, Terms of Service)
  - Real-time legal document validation
  - Deployment security verification
  
- **ğŸ§ª QA Agent** (665 lines + 230 lines expertise)
  - Manual UI testing automation with Puppeteer
  - Accessibility compliance checking
  - Cross-browser validation
  - 9 issue categories with 4 severity levels
  - 18+ QA best practices
  
- **ğŸ”§ SRE Agent** (1,620+ lines + 190 lines expertise)
  - Real-time pipeline monitoring (10-second polling intervals)
  - Automatic failure detection and self-healing
  - Linting error fixing (removes unused variables/functions)
  - Compliance agent error recovery
  - 5-stage failure recovery process
  - Version management and automated releases
  
- **ğŸ¤– SDET Agent** (CI/CD workflow integration)
  - Automated test generation
  - Feature verification
  - Test case coverage analysis
  
- **ğŸ”— Fullstack Agent** (1,278+ lines)
  - Intelligent code fixing with pattern matching
  - Test generation from compliance violations
  - Multi-knowledge collaboration
  - Auto-remediation of compliance issues

### 2. **Self-Healing CI/CD Pipeline**

**Concurrency-Optimized Workflow** with Smart Run Classification:
- âœ… **Parallel Test Chains**: Multiple test runs execute simultaneously
- âœ… **Serial Reruns**: Reruns group with their initial runs to prevent duplicate testing
- âœ… **Run Type Classification**: initial | retest | retry | diagnostic | manual
- âœ… **Smart Dashboard**: Clean GitHub Actions UI showing only active runs

**Automatic Error Detection & Fixing**:
- Linting errors â†’ Automatic removal of unused code
- Test failures â†’ Pattern-based fixes with validation
- Compliance violations â†’ Automatic remediation
- File path issues â†’ Working directory fixes
- Port conflicts â†’ Intelligent port cleanup

### 3. **Enterprise Compliance Framework**

**175+ Automated Checks** across 7 compliance standards - covering GDPR, CCPA, WCAG 2.1, ADA, OWASP Top 10, Licensing, and Legal Documents.

### 4. **Comprehensive Testing Infrastructure**

**59+ Automated Tests** across 5 frameworks (ESLint, Jest, Vitest, Playwright, Cypress) with continuous validation and accessibility testing.

### 5. **Real-Time Pipeline Monitoring**

Real-time SRE agent monitoring with 10-second polling intervals, automatic failure analysis, and intelligent recovery.

### 6. **Intelligent Linting Error Fixing**

Automatically removes unused variables/functions, detects duplicates, and fixes formatting issues before they cause failures.

### 7. **Web UI for Interactive Scanning**

Professional dashboard for real-time URL scanning, comprehensive issue analysis, AI-generated test cases, and code generation

- Console errors and page exceptions
- Failed network requests
- Common DOM and accessibility issues (missing image alts, broken images, missing form labels, bad anchors, heading order problems)
- Automatically generated recommended test cases (positive and negative)
- Simulated performance results (JMeter-like summary)
- **APIs Used:** Displays up to 10 API calls (fetch/XHR) detected on the scanned page
- **Playwright Example:** Shows a Playwright test code snippet for the first recommended test case
- **Cypress Example:** Shows a Cypress test code snippet for the first recommended test case

## Quick Start

### 1. Manual Scanning (Web UI)
```bash
npm install
npm start
# Visit http://localhost:3000 in your browser
```

### 2. Autonomous Agent (LangGraph)
```bash
npm install
npm start &              # Terminal 1: Start server
npm run agent "https://example.com"  # Terminal 2: Run agent
```

### 3. Run All Tests
```bash
npm install
npm run test:vitest     # Vitest (18 tests, <300ms)
npx jest --coverage     # Jest (5 tests with coverage)
npx playwright test     # Playwright (7+ E2E tests)
npm run test:cypress    # Cypress (22 E2E tests)
npx eslint . --ext .js  # ESLint linting
```

## Setup

1. **Install dependencies:**
	 ```bash
	 npm install
	 ```

2. **Run the server:**
	 ```bash
	 npm start
	 ```

3. **Open the web UI:**
	 Go to [http://localhost:3000](http://localhost:3000) in your browser. Enter a URL to scan.


## Features

- **Scan Results:**
	- Console errors, page exceptions, failed requests, and DOM/accessibility issues (max 25 items per scan)
- **Recommended Test Cases:**
	- 10 positive and 10 negative test cases are generated for the scanned page
- **Performance Results:**
	- Simulated JMeter-like summary: total/failed requests, resource count, average response time, page load time, throughput, and top resources
- **APIs Used:**
	- Displays up to 10 API calls (fetch/XHR) detected on the scanned page
- **Playwright Example:**
	- Shows a Playwright test code snippet for the first recommended test case
- **Cypress Example:**
	- Shows a Cypress test code snippet for the first recommended test case

## Autonomous Agent (Agentic Engineering Expert)

The project includes a powerful **LangGraph-based Agentic Engineering Expert** that autonomously scans production URLs, analyzes them using the actual product, and generates AI-powered improvement recommendations. This is your personal engineering expert that continuously evaluates external websites for quality, accessibility, and testing opportunities.

### What Makes It an Agentic Engineering Expert

The agent combines three specialized tools to provide expert-level QA analysis:

1. **Codebase Intelligence** - Understands your project structure and organization
2. **Real-World Testing** - Uses the actual product UI to scan external websites (like a real engineer would)
3. **Expert Recommendations** - Generates intelligent, context-aware improvement suggestions based on actual findings

### Agent Capabilities

The agent autonomously:

âœ… **Scans Production URLs in Real-Time**
- Analyzes any website: `https://yahoo.com`, `https://cbs.com`, `https://github.com`, etc.
- Uses Playwright to navigate and interact with sites just like a human QA engineer
- Extracts accessibility issues, performance metrics, API usage patterns
- Captures console errors, network failures, DOM problems

âœ… **Uses Your Actual Product to Test**
- Submits URLs to your deployed frontend
- Fills input fields and clicks buttons automatically
- Extracts comprehensive scan results from the UI
- Validates that the scanning system works correctly on real external sites

âœ… **Generates AI-Powered Recommendations**
- Creates 3 expert recommendations per URL analyzed:
  - **Accessibility Recommendations:** Specific improvements for WCAG 2.1 compliance
  - **Performance Recommendations:** Optimization strategies based on actual metrics
  - **Testing Recommendations:** Test coverage expansion and automation strategies
- Recommendations are context-aware - different for each URL based on findings

### Agent Architecture

The agent has three specialized tools working in concert:

#### Tool 1: scanCodebase()
- Recursively scans project directory (2 levels deep)
- Ignores node_modules, .git, coverage, test-results
- Returns file hierarchy with metadata:
  - File sizes and line counts
  - Directory structure
  - Code previews
- Perfect for understanding project organization

#### Tool 2: submitURLToFrontend()
- Uses Playwright for headless browser automation
- Navigates to your frontend UI (localhost:3000 or deployed instance)
- Fills URL input field with target website
- Clicks scan button to initiate real QA analysis
- Waits for results (up to 30 seconds)
- Extracts all result sections:
  - Scan results (console errors, DOM issues)
  - Generated test cases
  - Performance metrics
  - Detected APIs
  - Code generation examples (Playwright, Cypress)
  - **AI-generated recommendations**

#### Tool 3: analyzeResults() & generateRecommendations()
- Analyzes scan findings with intelligent pattern matching
- Counts issues by type (accessibility, performance, security)
- Generates expert recommendations based on:
  - Number and severity of accessibility issues
  - Performance metrics (load time, failed requests)
  - Detected APIs and testing opportunities
- Creates structured recommendations that are actionable and specific

### Agent Workflow

The agent executes in three sequential steps, simulating how a human QA engineer would work:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: Understand Your Project                  â”‚
â”‚ - Scans codebase structure                       â”‚
â”‚ - Identifies technologies and files              â”‚
â”‚ - Prepares for testing                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: Test Real Websites Using Your Product   â”‚
â”‚ - Navigates to frontend (your actual product)    â”‚
â”‚ - Submits external URLs for scanning             â”‚
â”‚ - Extracts comprehensive analysis results        â”‚
â”‚ - Validates your system works on live sites      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: Generate Expert Recommendations         â”‚
â”‚ - Analyzes findings intelligently                â”‚
â”‚ - Identifies improvement opportunities           â”‚
â”‚ - Creates 3 context-aware recommendations       â”‚
â”‚ - Prioritizes by impact and effort              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Using the Agent

#### Single URL Analysis
```bash
# Start your product
npm start &

# Analyze a specific website
npm run agent "https://example.com"
```

#### Multiple URL Analysis (Default)
```bash
# Analyzes 3 production websites by default
npm run agent

# Scans: yahoo.com, cbs.com, github.com
# Each gets personalized recommendations
```

#### Programmatic Usage
```javascript
const { QAAgent } = require("./agent.js");

const agent = new QAAgent();
const state = await agent.run("https://github.com");

// Access results
console.log(state.codebaseInfo);        // Your project structure
console.log(state.scanResults);         // Scans of all URLs
console.log(state.analysis);            // AI recommendations
```

#### Example Output
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ Agentic Engineering Expert - LangGraph â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Step 1: Scanning codebase structure...
âœ… Codebase scanned successfully

ğŸ“‹ Project Files: 45 total
  - JavaScript files: 32
  - HTML/CSS: 5
  - Config files: 8

ğŸš€ Step 2: Testing production URLs...

ğŸ“ Scanning: https://www.yahoo.com
ğŸŒ Using your frontend at localhost:3000
ğŸ“ Submitting URL for analysis...
âœ… Analysis complete

ğŸ“Š Findings:
  - Issues: 14 detected
  - Test Cases: 20 recommended
  - APIs: 5 identified
  - Performance: Good (< 3s load time)

ğŸ’¡ circleQA.ai Engineer's Recommendations:

  1. ğŸ¯ Critical: Fix 9 accessibility issues including missing alt text 
     and ARIA labels. This blocks ~15% of users and hurts SEO ranking.

  2. âš¡ Performance: Page load is solid. Monitor Core Web Vitals 
     monthly using Google Lighthouse. Implement Service Workers 
     for offline capability.

  3. ğŸ§ª Testing: Create automated tests for 5 detected APIs and 
     critical user flows. Target 80%+ code coverage to catch 
     regressions early.

ğŸ“ Scanning: https://www.cbs.com
âœ… Analysis complete with personalized recommendations

ğŸ“ Scanning: https://www.github.com
âœ… Analysis complete with personalized recommendations

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âœ¨ Agentic Engineering Expert Analysis Complete
```

### How It Works on Production Deploy

When the agent runs in CI/CD (GitHub Actions):

1. **Your product is deployed** - Frontend runs at specified URL
2. **Agent analyzes real websites** - Tests your system against production URLs
3. **Recommendations are generated** - Specific to each URL's findings
4. **Results are logged** - Visible in CI output for team review
5. **Quality insights provided** - Actionable improvements for all analyzed sites

### Agent Requirements

1. **Server running** - Your frontend must be accessible (localhost or deployed)
2. **Valid URLs** - Target websites must be publicly accessible
3. **Dependencies installed** - Playwright, Node.js modules
4. **Optional:** Specify URLs - Default scans 3 production websites

### Key Differences from Manual Testing

| Aspect | Manual Testing | Agentic Expert |
|--------|---|---|
| **Speed** | 5-10 min per site | 30 seconds per site |
| **Consistency** | Variable | 100% consistent |
| **URLs Covered** | 1-2 | Unlimited (batch multiple) |
| **Recommendations** | Manual notes | AI-generated, specific |
| **Integration** | Manual process | Automated in CI/CD |
| **Scale** | Limited | Unlimited production sites |

### Future Enhancements

- [ ] Multi-URL batch scanning with report generation
- [ ] LLM-based result interpretation for deeper insights
- [ ] Scheduled scans with historical trending
- [ ] Slack/Email notifications with key findings
- [ ] PDF report generation for stakeholders
- [ ] Integration with bug tracking systems (Jira, GitHub Issues)

### Full Documentation
See [AGENT.md](./AGENT.md) for comprehensive technical documentation including state management, error handling, and advanced configuration.

## API

- `POST /scan` â€” Accepts `{ url: "https://example.com" }` and returns scan results, test cases, and performance summary as JSON

## Development & Testing

### Comprehensive Test Coverage

circleQA.ai generates unlimited tests across any testing framework to ensure reliability, maintainability, and code quality. We can generate as many tests as your organization needs, with full coverage across your entire codebase.

#### Test Suite Capabilities

| Framework | Capability | Purpose | Coverage |
|-----------|-----------|---------|----------|
| **ESLint** | Continuous static analysis | Code quality, linting standards, best practices | All source files |
| **Jest** | Unlimited unit tests | Server-side logic, utilities, core functions | Complete coverage |
| **Vitest** | Fast modern unit tests | Server, browser, integration components | Full codebase |
| **Playwright** | Modern E2E browser automation | UI interactions, cross-browser compatibility | All user flows |
| **Cypress** | Comprehensive E2E testing | Complex workflows, accessibility, integration | Business-critical paths |

**Unlimited automated tests ensuring comprehensive coverage - generated to match your needs**

### Thorough Unit Testing Across All Languages

Each programming language in the project is validated with dedicated unit tests:

#### JavaScript (Node.js) - Backend
- **Functions Tested:** `normalizeUrl()`, `mapIssue()`, API scanning logic
- **Frameworks:** Jest, Vitest
- **Tests:** 8 dedicated tests
- **Focus:** URL normalization, issue mapping, error handling

#### JavaScript (Browser) - Frontend
- **Functions Tested:** `renderResults()`, `generatePlaywrightExample()`, `generateCypressExample()`
- **Frameworks:** Jest, Vitest
- **Tests:** 6 dedicated tests
- **Focus:** Code generation, result rendering, template logic

#### HTML/CSS Structure
- **Validation:** Semantic HTML structure, CSS styling rules, responsive design
- **Frameworks:** Vitest, Cypress
- **Tests:** 19+ dedicated tests
- **Focus:** DOM structure, layout consistency, accessibility compliance

#### Integration Testing
- **Coverage:** Full scan workflow, URL handling, test case generation, API detection, performance metrics
- **Frameworks:** Vitest
- **Tests:** 6 dedicated tests
- **Focus:** End-to-end logic flow and data transformations

### Thorough UI Testing with Multiple Tools

The project uses **3 complementary E2E testing frameworks** to catch UI issues from different angles:

#### Playwright Tests (`playwright-tests/`)
- **Focus:** Modern browser automation and cross-browser compatibility
- **Tests:** 7+ UI validation tests
- **Coverage:** Element visibility, placeholder text, readonly attributes, form validation
- **Advantage:** Lightweight, fast, good for rapid UI validation

#### Cypress Tests (`cypress/e2e/scan-ui.cy.js`)
- **Focus:** User-centric testing and interactive flows
- **Tests:** 7 comprehensive UI tests
- **Coverage:** Homepage loading, result boxes, input validation, readonly states, error handling
- **Advantage:** Great developer experience, interactive debugging

#### Accessibility & Integration Tests (`cypress/e2e/accessibility.cy.js`)
- **Focus:** Accessibility compliance and full workflow integration
- **Tests:** 15 comprehensive tests including:
  - Heading hierarchy and semantic structure
  - Form element labels and placeholders
  - Keyboard navigation support
  - Responsive viewport testing (mobile, tablet, desktop)
  - Color contrast validation
  - Complete scan flow integration
  - UI state consistency across interactions
- **Advantage:** Ensures usability for all users, catches real-world issues

**Why Multiple Frameworks?**
- **Playwright** catches structural issues fast
- **Cypress (UI)** validates user interactions thoroughly
- **Cypress (Accessibility)** ensures compliance and real-world workflows
- Combined approach ensures no UI bugs, accessibility issues, or user experience problems

### Code Quality & Maintainability

#### Linting
```bash
npx eslint . --ext .js
```
- **Status:** 0 errors, 6 warnings
- **Coverage:** All JavaScript files including server, browser, tests
- **Standard:** ESLint v9+ with flat config

#### Unit Testing with Coverage
```bash
npx jest --coverage
```
- **Test Count:** 5 comprehensive unit tests
- **Coverage:** Server functions, utilities, browser logic
- **Metrics:** Statement, branch, function, and line coverage

#### Fast Unit Testing
```bash
npm run test:vitest
```
- **Test Count:** 18 tests (4 test files)
- **Speed:** <300ms execution
- **Coverage:** Includes HTML/CSS validation and integration tests

#### Modern E2E Testing
```bash
npx playwright test
```
- **Test Count:** 7+ tests
- **Execution:** <2 seconds
- **Coverage:** UI element validation, form interactions

#### Comprehensive E2E Testing
```bash
npm run test:cypress
```
- **Test Count:** 22 tests (2 spec files)
- **Execution:** <15 seconds
- **Coverage:** UI validation, accessibility, integration flows

#### Autonomous Agent Testing
```bash
npm start &
npm run agent "https://example.com"
```
- **Capabilities Tested:**
  - âœ… Codebase scanning and analysis
  - âœ… Browser automation with Playwright
  - âœ… UI interaction (input, button clicks)
  - âœ… Results extraction and analysis
- **Coverage:** All three agent tools (scanCodebase, submitURLToFrontend, analyzeResults)
- **Validates:** Autonomous workflow and data processing pipeline

### Automated CI/CD Pipeline

GitHub Actions runs **5 parallel jobs** on every push and pull request:

```yaml
jobs:
  1. lint - ESLint validation
  2. unit-test - Jest with coverage
  3. test-vitest - Vitest with coverage
  4. test-playwright - Playwright E2E tests
  5. test-cypress - Cypress E2E + accessibility tests
```

**All jobs must pass** before code can be merged, ensuring:
- âœ… No style violations
- âœ… No broken unit tests
- âœ… No UI regressions
- âœ… No accessibility issues
- âœ… No integration failures

### Running All Tests

```bash
# Run all tests at once
npm run test:vitest -- --run && \
npx jest && \
npx playwright test && \
npm run test:cypress && \
npx eslint . --ext .js
```

### Test Maintenance & Usability

The test suite is designed for **ease of maintenance** and **maximum usability**:

1. **Clear Test Organization**
   - Unit tests in `unit-tests/` and `vitest-tests/`
   - E2E tests in `playwright-tests/` and `cypress/e2e/`
   - Each test file focuses on a specific component

2. **Descriptive Test Names**
   - Tests clearly state what is being validated
   - Easy to identify failing tests and their purpose
   - Self-documenting test code

3. **Comprehensive Error Messages**
   - Test failures include expected vs actual values
   - Line numbers and stack traces for debugging
   - Coverage reports for identifying gaps

4. **Low Maintenance Overhead**
   - Minimal configuration required
   - Tests run in parallel for speed
   - Clear separation of concerns

### Linting

```bash
npx eslint . --ext .js
```

### Unit Tests (Jest)
```bash
npx jest --coverage
```

### Unit Tests (Vitest)
```bash
npm run test:vitest -- --run --coverage
```

### Playwright Tests
```bash
npx playwright test
```

### Cypress Tests
```bash
npm run test:cypress
```

## Autonomous Agent

This project includes a **LangGraph-based autonomous agent** that combines codebase analysis with UI interaction to provide comprehensive QA insights.

### Agent Overview

The agent (`agent.js`) uses LangChain and LangGraph to orchestrate three specialized tools:

1. **scanCodebase()** - Analyzes project structure recursively (2 levels deep)
   - Scans all `.js`, `.json`, `.css`, `.html` files
   - Ignores: `node_modules/`, `.git/`, `coverage/`, `test-results/`, `.next/`, `dist/`, `build/`
   - Returns: File count, directory structure, technology stack

2. **submitURLToFrontend()** - Uses Playwright for browser automation
   - Navigates to application URL
   - Fills in scan input field with detected codebase info
   - Clicks "Scan" button
   - Waits for results to load
   - Extracts findings from result sections

3. **analyzeResults()** - Processes scan findings
   - Counts identified issues
   - Extracts test cases and performance metrics
   - Detects APIs and code generation capabilities
   - Generates summary statistics

### Running the Agent

**Basic Usage:**
```bash
npm run agent "https://example.com"
```

**With Running Server:**
```bash
# Terminal 1: Start the application
npm start

# Terminal 2: Run the agent
npm run agent "http://localhost:3000"
```

**Programmatic Usage:**
```javascript
const { QAAgent } = require('./agent.js');

const agent = new QAAgent();
await agent.run('http://localhost:3000');

// Access results:
// agent.scanResults - Raw API response
// agent.analysis - Processed statistics
```

### Agent Workflow

The agent follows this 3-step workflow:

```
START
  â†“
[1] Scan Codebase
    â””â”€â†’ Analyze project structure
        Identify technologies used
        Return file statistics
  â†“
[2] Submit to Frontend
    â””â”€â†’ Automation via Playwright
        Navigate to app
        Input scan data
        Extract results
  â†“
[3] Analyze Results
    â””â”€â†’ Process findings
        Generate statistics
        Create summary report
  â†“
END (Display report)
```

### Example Output

```
=== CODEBASE INFO ===
Total files: 45
JavaScript files: 32
JSON files: 5
CSS files: 3
HTML files: 5

=== ANALYSIS ===
Issues found: 12
Test cases detected: 8
Performance metrics: 4
APIs identified: 3
Code generation capable: true
```

### Agent Capabilities

âœ… **Codebase Analysis**
- Recursive file scanning
- Technology detection
- Project structure mapping

âœ… **UI Automation**
- Browser navigation
- Form interaction
- Result extraction
- Screenshot capability

âœ… **Result Processing**
- Issue aggregation
- Metric calculation
- Report generation
- Statistics summary

### Testing the Agent

Run the agent with the development server:

```bash
# In one terminal
npm start

# In another terminal
npm run agent "http://localhost:3000"
```

**What gets tested:**
- Codebase scanning accuracy (file counts, structure)
- Frontend UI interaction (input/button functionality)
- Result extraction (all sections parsed correctly)
- Error handling (network, timeout scenarios)

**Coverage:**
- Agent initialization
- Tool execution (all three tools)
- Result aggregation
- Error recovery

### Requirements & Dependencies

- **Node.js**: v20 or later
- **Browser**: Chromium (installed by Playwright)
- **Dependencies**: langchain, @langchain/core, @langchain/langgraph, playwright

### Future Enhancements

- [ ] Multi-URL batch scanning
- [ ] LLM-based result interpretation
- [ ] Scheduled scans with report generation
- [ ] Multi-agent collaboration for distributed analysis
- [ ] WebSocket support for real-time updates
- [ ] Result export (JSON, PDF, HTML reports)
- [ ] Performance trend tracking
- [ ] Custom test case generation rules

For detailed agent documentation, see [AGENT.md](./AGENT.md).

## CI/CD & Automated Testing Infrastructure

### GitHub Actions Workflows

#### 1. **Continuous Integration (CI) Workflow** (`ci.yml`)
Runs on every push and pull request with comprehensive testing:

- **Security Scanning** - npm audit, dependency vulnerability checks, secret detection
- **Linting** - ESLint validation across all JavaScript files
- **Unit Testing** - Jest with code coverage reporting
- **E2E Testing** - Playwright for cross-browser testing
- **Vitest** - Fast unit tests with coverage metrics
- **Cypress** - Full E2E test suite for UI interactions
- **Conditional Execution** - Tests run independently even if linting fails (with `if: always()`)

**Test Results:**
- Each test suite can be run independently
- Failed tests trigger the SRE Engineer workflow automatically
- All test jobs depend on lint but continue even if lint warnings occur

#### 2. **Agentic SRE Engineer Workflow** (`agentic-sre-engineer.yml`)
Automatically diagnoses and fixes failing CI jobs:

**Capabilities:**
- âœ… Detects failing workflow runs and analyzes root causes
- âœ… Removes unused ESLint directives from generated files
- âœ… Adds missing globals (URL, etc.) to ESLint configuration
- âœ… Fixes unused variables and quote consistency issues
- âœ… Handles port conflicts (EADDRINUSE errors)
- âœ… Configures proper server shutdown and cleanup
- âœ… Retries tests multiple times to handle intermittent failures
- âœ… Auto-commits fixes and pushes to main branch
- âœ… Triggers CI workflow after making fixes to validate results
- âœ… Sends email notifications on completion

**Key Features:**
- Graceful error handling with non-critical operations
- Timeout prevention (hard stop at 25 minutes)
- Multiple iteration support (up to 3 attempts)
- Intelligent issue detection from workflow logs
- Git authentication using GITHUB_TOKEN with proper URL rewriting

**How It Works:**
1. Monitors failed workflow runs (lint, tests)
2. Analyzes logs to identify specific issues
3. Makes intelligent code changes:
   - Applies ESLint --fix
   - Updates configuration files
   - Improves error handling
   - Fixes server/port issues
4. Commits changes and retriggers CI
5. Sends summary via email

### Running Tests Locally

**All Tests:**
```bash
npm test              # Run all test suites
```

**Individual Test Suites:**
```bash
npm run test:vitest   # Vitest (18 tests, <300ms)
npx jest --coverage   # Jest (5 tests with coverage)
npx playwright test   # Playwright (7+ E2E tests)
npm run test:cypress  # Cypress (22 E2E tests)
npx eslint . --ext .js  # Linting
```

**Server Management:**
```bash
# Terminal 1: Start server
npm start

# Terminal 2: Run a single test
npx playwright test

# Or run tests with server management
npm run test:cypress  # Uses start-server-and-test
```

## Notes & Limitations

- Results are limited to 25 items per scan
- Puppeteer downloads a Chromium binary on first install (requires network access)
- Some advanced accessibility or performance issues may not be detected
- For troubleshooting Puppeteer launch issues, ensure Chrome/Chromium is available and accessible
- SRE Agent requires GITHUB_TOKEN with `contents: write` permission
- SMTP configuration needed for email notifications (SMTP_USER, SMTP_PASS, SMTP_HOST, SMTP_PORT)

## License

MIT
